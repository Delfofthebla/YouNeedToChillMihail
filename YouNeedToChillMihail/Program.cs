using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

namespace YouNeedToChillMihail;

public class Program
{
    private static Lazy<Settings> _settings = new();
    private static Settings Settings => _settings.Value;
    
    private static IPatcherState<ISkyrimMod, ISkyrimModGetter>? _state;
    internal static IPatcherState<ISkyrimMod, ISkyrimModGetter> State => _state!;
    
    public static async Task<int> Main(string[] args)
    {
        return await SynthesisPipeline.Instance
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
            .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
            .Run(args);
    }

    private static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        _state = state;
        var blacklistedIds = string.Join(",", Settings.Blacklist).Split(",").ToList();
        //Console.WriteLine($"Damage Nerf: {Settings.DamageNerfPercent}, Damage Multiplier: {Settings.DamageNerfPercent}");
        //Console.WriteLine($"Health Nerf: {Settings.HealthNerfPercent}, Health Multiplier: {Settings.HealthNerfPercent}");
        
        // ---- Pass 1: RACE records from Mihail plugins ----
        foreach (var race in state.LoadOrder.PriorityOrder.Race().WinningOverrides())
        {
            if (!IsFromTargetPlugin(race.FormKey.ModKey))
                continue;

            if (ShouldSkip(race.FormKey.ModKey, race.EditorID, blacklistedIds))
            {
                Console.WriteLine("Skipping " + race.EditorID + " race from mod " + race.FormKey.ModKey);
                return;
            }

            ApplyNerfsToRaceRecord(state, race);
        }

        // ---- Pass 2: NPC records from Mihail plugins ----
        foreach (var npc in state.LoadOrder.PriorityOrder.Npc().WinningOverrides())
        {
            if (!IsFromTargetPlugin(npc.FormKey.ModKey))
                continue;

            if (ShouldSkip(npc.FormKey.ModKey, npc.EditorID, blacklistedIds))
            {
                Console.WriteLine("Skipping " + npc.EditorID + " npc from mod " + npc.FormKey.ModKey);
                return;
            }

            ApplyNerfsToNpcRecord(state, npc);
        }
    }

    private static void ApplyNerfsToRaceRecord(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IRaceGetter race)
    {
        var raceCopy = state.PatchMod.Races.GetOrAddAsOverride(race);
        if (raceCopy.Attacks is {Count: > 0})
        {
            foreach (var atk in raceCopy.Attacks)
            {
                var data = atk?.AttackData;
                if (data is null)
                    continue;

                var oldValue = data.DamageMult;
                data.DamageMult = GetNerfedFloatValue(data.DamageMult, Settings.DamageNerfPercent);
                Console.WriteLine($"Ra: {raceCopy.EditorID} Damage for attack '{atk?.AttackEvent}' nerfed from {oldValue} to {data.DamageMult}");
            }
        }

        var oldUnarmed = raceCopy.UnarmedDamage;
        raceCopy.UnarmedDamage = GetNerfedFloatValue(raceCopy.UnarmedDamage, Settings.DamageNerfPercent);
        Console.WriteLine($"Race: {raceCopy.EditorID} Unarmed Damage nerfed from {oldUnarmed} to {raceCopy.UnarmedDamage}");

        var oldHealth = raceCopy.Starting[BasicStat.Health];
        raceCopy.Starting[BasicStat.Health] = GetNerfedFloatValue(raceCopy.Starting[BasicStat.Health], Settings.HealthNerfPercent);
        Console.WriteLine($"Race: {raceCopy.EditorID} Starting Health nerfed from {oldHealth} to {raceCopy.Starting[BasicStat.Health]}");
    }

    private static void ApplyNerfsToNpcRecord(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, INpcGetter npc)
    {
        var npcCopy = state.PatchMod.Npcs.GetOrAddAsOverride(npc);

        // Nerf NPC.Attacks[*].AttackData.DamageMult
        if (npcCopy.Attacks is {Count: > 0})
        {
            foreach (var atk in npcCopy.Attacks)
            {
                var data = atk?.AttackData;
                if (data is null)
                    continue;

                var oldValue = data.DamageMult;
                data.DamageMult = GetNerfedFloatValue(data.DamageMult, Settings.DamageNerfPercent);
                Console.WriteLine($"NPC: {npcCopy.EditorID} Damage for attack '{atk?.AttackEvent}' nerfed from {oldValue} to {data.DamageMult}");
            }
        }

        var oldHealthOffset = npcCopy.Configuration.HealthOffset;
        npcCopy.Configuration.HealthOffset = GetNerfedShortValue(npcCopy.Configuration.HealthOffset, Settings.HealthNerfPercent);
        Console.WriteLine($"NPC: {npcCopy.EditorID} Health Offset nerfed from {oldHealthOffset} to {npcCopy.Configuration.HealthOffset}");

        if (npcCopy.PlayerSkills != null)
        {
            var oldHealth = npcCopy.PlayerSkills.Health;
            npcCopy.PlayerSkills.Health = GetNerfedUShortValue(npcCopy.PlayerSkills.Health, Settings.HealthNerfPercent);
            Console.WriteLine($"NPC: {npcCopy.EditorID} Health nerfed from {oldHealth} to {npcCopy.PlayerSkills.Health}");
        }
    }

    private static float GetNerfedFloatValue(float oldValue, float multiplier) => (float)Math.Round(oldValue * (1 - Math.Sign(oldValue) * multiplier), 4);

    private static short GetNerfedShortValue(short oldValue, float multiplier)
    {
        // Convert to double for calculation, then clamp and cast back
        var result = oldValue * (1 - Math.Sign(oldValue) * multiplier);
        return (short)Math.Clamp(Math.Round(result), short.MinValue, short.MaxValue);
    }
    
    private static ushort GetNerfedUShortValue(ushort oldValue, float multiplier)
    {
        var result = oldValue * (1 - Math.Sign(oldValue) * multiplier);
        return (ushort)Math.Clamp(Math.Round(result), ushort.MinValue, ushort.MaxValue);
    }

    private static bool IsFromTargetPlugin(ModKey mk) => mk.FileName.String.Contains("mihail", StringComparison.OrdinalIgnoreCase);
    
    private static bool ShouldSkip(ModKey mod, string? editorId, IEnumerable<string> blacklistedIDs)
        => Settings.IgnoredMods.Contains(mod)
            || editorId == null
            || blacklistedIDs.Any(editorId.HasValueAndContainsId);
}
